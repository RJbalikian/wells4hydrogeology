<h1>Wells 4 Hydrogeology (w4h)</h1>
<p>The w4h Python package is a package designed jointly by the Illinois State Geological Survey and Illinois State Water Survey.</p>
<p>It is designed to read in geology data from wells and create a layered, gridded hydrogeologic model of a study region, all within a python environment, automating and performing tasks often carried out in a dedicated GIS software.</p>
<p>The w4h package contains all the functions needed for getting N layers of a hydrogeology grid. 
Though the source code is split into separate modules, all functions are designed to be accessed directly from the w4h module (example: w4h.read_study_area())</p>
<p>The w4h module is designed to be flexible and customizable, allowing various kinds of data to be read in, with many different kinds of initial structures.</p>
<p>Using well descriptions from these database tables, the code contained here extracts, manipulates, and organizes the data to be used for hydrogeologic modeling. The scripts here can be used for specific regions of interests/study areas within the state, or for the state as a whole.</p>
<h1>API Documentation</h1>
<p>API Documentation <a href="main.html">here</a></p>
<h1>Dependencies</h1>
<p>The w4h module has the following dependencies:
- numpy
- pandas
- rioxarray (and therefore xarray)
- geopandas
- matplotlib
- scipy
- owslib</p>
<h1>Inputs</h1>
<p>Required inputs include:
- ISGS_DOWNHOLE_DATA: A table in the ISGS database containing descriptions of well intervals for wells throughout the state.
- ISGS_HEADER: A table in the ISGS database containing the metadata for all the wells, including API number, well location, and in some cases elevation.
- XYZData (optional): A separate table containing updated location information for each well, particularly updated elevation data from Lidar products
- Surface elevation: raster data containing the surface elevation of the study area or state.
- Bedrock elevation: raster data containing the bedrock elevation of the study area or state.
- Model grid: raster data whose resolution and cell locations align with that of the hydrogeologic model (i.e., in MODFLOW)
- Lithology data: "definitions" to convert raw, manual well descriptions to broad lithological categories and then to a target lithology (e.g., coarse sediment).</p>
<h2>master_notebook contains an interactive jupyter notebook with all the steps for running the main body of the script</h2>
<h2>w4h folder contains all scripts with functions used</h2>
<ul>
<li>readData: functions for reading in various files</li>
<li>mapping: functions for mapping or performing geospatial analysis</li>
<li>cleanData: functions for cleaning the data</li>
<li>classify: functions for classifying the data</li>
</ul>
<h2>resources folder contains all the files that are read in/used by the scripts</h2>
<ul>
<li>ISGS_HEADER_yyyy-mm-dd.TXT: tabular data exported from ISGS oracle database containing "header" information (i.e., metadata) about all the wells</li>
<li>ISGS_DOWNHOLE_DATA_yyyy-mm-dd.TXT: tabular data exported from ISGS oracle database containing geologic information about wells in the state</li>
<li>xyzData_yyyy-mm-dd.csv: most recent update of statewide wells with API, Latitude, Longitude, and surface elevation extracted from statewide lidar topography</li>
</ul>
<h2>Intended workflow</h2>
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script> console.log(mermaid.version); </script>
<p>```mermaid
flowchart TD
    subgraph setup["Set up Files"]
        direction RL</p>
<pre><code>    A0((file_setup))

    A1[(db_dir)]
    A2{{log_dir}}
    A3{{verbose}}
    A4{{log}}

    A1--&gt;A0
    A2-.-&gt;A0
    A3-.-&gt;A0
    A4-.-&gt;A0
end

subgraph read["Read Data"]
    direction TB
    subgraph readraw["read_raw_txt()"]
        direction RL
        B0(("read_raw_txt()"))
        B1[(filepath)]
        B2{{"pd.read_csv(**kwargs)"}}

        B1--&gt;B0
        B2-.-&gt;B0
    end

    subgraph defineDtypes["define_dtypes()"]
        direction RL
        C0(("define_datatypes()"))
        C1[(df)]
        C2{{"dtypes"}}

        C1--&gt;C0
        C2--&gt;C0
    end
    readraw--&gt;defineDtypes
end

subgraph readSA["Read Study Area"]
    direction RL
    D0(("read_study_area()"))
    D1[(studyareapath)]

    D1---D0

end

subgraph Read_Grids["Read Grids"]
    direction RL
    E0(("read_grids()"))
    E1[(datapath)]
    E2{{grid_type}}
    E3[(study_area)]
    E4{{clip_to_studyarea}}
    E5{{use_service}}

    E1--&gt;E0
    E2-.-&gt;E0
    E3-.-&gt;E0
    E4-.-&gt;E0
    E5-.-&gt;E0

end

subgraph clipdatatoSA["Clip Data to Study Area"]
    direction TB
    subgraph xyzmetaMerge
        direction RL
        F0(("xyz_metadata_merge()"))
        F1((xyz))
        F2((metadata))

        F1--&gt;F0
        F2-.-&gt;F0
    end

    subgraph coords2geometry
        direction RL
        G0(("coords2geometry()"))
        G1[(df)]
        G2{{xcol}}
        G3{{ycol}}
        G4{{zcol}}
        G5{{crs}}

        G1--&gt;G0
        G2-.-&gt;G0
        G3-.-&gt;G0
        G4-.-&gt;G0
        G5-.-&gt;G0

    end

    subgraph clipdata[Clip Data]
        direction RL
        H0(("clip_gdf2study_area()"))  
        H1[("study_area")]
        H2[("gdf")]
        H3{{"gdf_crs"}}

        H1--&gt;H0
        H2-.-&gt;H0
        H3-.-&gt;H0
    end

    xyzmetaMerge --&gt; coords2geometry  
    coords2geometry --&gt; clipdata  
end

subgraph clean["Clean Data"]
    direction TB

    subgraph nonlocated
        direction RL
        I0(("remove_nonlocated()"))
        I1[(df)]
        I2[(metadata_df)]

        I1--&gt;I0
        I2--&gt;I0
    end

    subgraph notopo
        direction RL
        J0(("remove_no_topo()"))
        J1[(df)]

        J1--&gt;J0
    end

    subgraph nodepth
        direction RL
        K0(("drop_no_depth()"))
        K1[(df)]

        K1--&gt;K0
    end

    subgraph baddepth
        direction RL
        L0(("drop_bad_depth()"))
        L1[(df)]

        L1--&gt;L0
    end

    subgraph noformation
        direction RL
        M0(("drop_no_formation()"))
        M1[(df)]

        M1--&gt;M0
    end

    subgraph merge["MERGE:NEEDED?"]
        direction RL
        N0((merge))
    end

    nonlocated--&gt; notopo
    notopo--&gt;nodepth
    nodepth--&gt;baddepth
    baddepth--&gt;noformation
    noformation--&gt;merge
end

subgraph classify["Classify Well Descriptions"]
    direction TB

    subgraph getterms
        direction RL
        O0(("get_search_terms()"))
        O1[("spec_dir()")]
        O2{{"spec_glob_pattern()"}}
        O3[("start_dir()")]
        O4{{"start_glob_pattern()"}}

        O1--&gt;O0
        O2--&gt;O0
        O3-.-&gt;O0
        O4--&gt;O0
    end

    subgraph readterms
        direction RL
        P0(("read_dictionary_terms()"))
        P1{{dict_file}}

        P1--&gt;P0
    end

    readtermsIter[["Iterate read_terms() as needed"]]

    subgraph define[Define]
        direction LR

        subgraph specdefine['Define Exact Matches]
            direction RL
            Q0(("specific_define()"))
            Q1[(df)]
            Q2[(terms_df)]

            Q1--&gt;Q0
            Q2--&gt;Q0
        end

        subgraph startdefine["Define Substring Matches"]
            direction RL
            R0(("start_define()"))
            R1[(df)]
            R2[(terms_df)]

            R1--&gt;R0
            R2--&gt;R0                
        end

        subgraph depthdefine["Define by Depth"]
            direction RL
            S0(("depth_define()"))
            S1[(df)]
            S2[(thresh)]

            S1--&gt;S0
            S2--&gt;S0                
        end

        specdefine~~~startdefine
        startdefine~~~depthdefine
    end

    subgraph fillunclass
        direction RL
        T0(("fill_unclassified()"))
        T1[(df)]

        T1--&gt;T0
    end

    subgraph readlith
        direction RL
        U0(("read_lithologies()"))
    end

    subgraph mergelith
        direction RL
        V0(("merge_lithologies()"))
        V1[(df)]
        V2[(targinterps_df)]

        V1--&gt;V0
        V2--&gt;V0
    end

    getterms-.-&gt;readterms
    readterms-.-&gt;readtermsIter
    readtermsIter -.-&gt;define
    define--&gt;fillunclass
    fillunclass--&gt;readlith
    readlith--&gt;mergelith
end

subgraph get_layers["Get (Hydro)geologic Layers"]
    direction TB

    subgraph uniquewells
        direction RL
        W0(("get_unique_wells()"))
        W1[(df)]

        W1--&gt;W0
    end

    subgraph sortdf
        direction RL
        X0(("sort_dataframe()"))
        X1[(df)]
        X2{{sort_cols}}
        X3{{remove_nans}}

        X1--&gt;X0
        X2--&gt;X0
        X3-.-&gt;X0
    end

    subgraph alignrasters
        direction RL
        Y0(("align_rasters()"))
        Y1[(grids_unaligned)]
        Y2[(modelgrid)]

        Y1--&gt;Y0
        Y2--&gt;Y0
    end

    subgraph driftthick
        direction RL
        Z0(("get_drift_thick()"))
        Z1[(surface)]
        Z2[(bedrock)]
        Z3{{layers}}
        Z4{{plot}}

        Z1--&gt;Z0
        Z2--&gt;Z0
        Z3-.-&gt;Z0
        Z4-.-&gt;Z0
    end

    subgraph sampleraster
        direction RL
        AA0(("sample_raster_points()"))
        AA1[(raster)]
        AA2[(points_df)]
        AA3{{new_col}}

        AA1--&gt;AA0
        AA2--&gt;AA0
        AA3-.-&gt;AA0
    end

    sampleRasterIter[["Iterate sample_raster_points() as needed"]]

    subgraph layerdepths
        direction RL
        BB0(("get_layer_depths()"))
        BB1[(well_metadata)]
        BB2{{no_layers}}

        BB1--&gt;BB0
        BB2-.-&gt;BB0
    end

    subgraph mergetables
        direction RL
        CC0(("merge_tables()"))
        CC1[(data_df)]
        CC2[(header_df)]
        CC3{{data_cols=None}}
        CC4{{header_cols=None}}
        CC5{{auto_pick_cols}}
        CC6{{"pd.merge(**kwargs)"}}

        CC1--&gt;CC0
        CC2--&gt;CC0
        CC3-.-&gt;CC0
        CC4-.-&gt;CC0
        CC5-.-&gt;CC0
        CC6-.-&gt;CC0
    end

    subgraph layertarg
        direction RL
        DD0(("layer_target_thick()"))
        DD1[(df)]
        DD2{{depth_top_col='TOP'}}
        DD3{{depth_bot_col='BOTTOM'}}

        DD1--&gt;DD0
        DD2-.-&gt;DD0
        DD3-.-&gt;DD0
    end

    subgraph layerinterp
        direction RL
        EE0(("layer_interp()"))
        EE1[(points)]
        EE2[(grid)]
        EE3{{return_type='dataarray'}}
        EE4{{targetcol='TARG_THICK_PER'}}
        EE5{{"scipy.interpolate(**kwargs)"}}

        EE1--&gt;EE0
        EE2--&gt;EE0
        EE3-.-&gt;EE0
        EE4-.-&gt;EE0
        EE5-.-&gt;EE0  
    end

    uniquewells--&gt;sortdf
    sortdf--&gt;alignrasters
    alignrasters--&gt;driftthick
    driftthick--&gt;sampleraster
    sampleraster--&gt;sampleRasterIter
    sampleRasterIter--&gt;layerdepths
    layerdepths--&gt;mergetables
    mergetables--&gt;layertarg
    layertarg--&gt;layerinterp

end

subgraph export["Export"]
    direction RL

    subgraph exportdf
        direction RL
        GG0(("export_dataframe()"))
        GG1[(df)]
        GG2{{out_dir}}
        GG3{{filename}}
        GG4{{datestamp=True}}

        GG1--&gt;GG0
        GG2--&gt;GG0
        GG3--&gt;GG0
        GG4-.-&gt;GG0
    end

    subgraph exportdata
        direction RL
        HH0(("export_grids()"))
        HH1[(grid_data)]
        HH2{{out_path}}
        HH3{{file_id}}
        HH4{{filetype='tif'}}
        HH5{{variable_sep=True}}
        HH6{{date_stamp=True}}

        HH1--&gt;HH0
        HH2--&gt;HH0
        HH3-.-&gt;HH0
        HH4-.-&gt;HH0
        HH5-.-&gt;HH0
        HH6-.-&gt;HH0
    end

    exportdf~~~exportdata
end

setup--&gt;read
read--&gt;readSA
readSA--&gt;Read_Grids
Read_Grids--&gt;clipdatatoSA
clipdatatoSA--&gt;clean
clean--&gt;classify
classify--&gt;get_layers
get_layers--&gt;export
</code></pre>
<p>```</p>