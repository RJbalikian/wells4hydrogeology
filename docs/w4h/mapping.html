<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>w4h.mapping API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>w4h.mapping</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import datetime
import json
import pathlib
import os


import rioxarray as rxr
import xarray as xr
import geopandas as gpd
import pandas as pd
import numpy as np
import shapely
from owslib.wcs import WebCoverageService
from shapely.geometry import Point
from urllib.request import urlopen
from rasterio import MemoryFile

import w4h

lidarURL = r&#39;https://data.isgs.illinois.edu/arcgis/services/Elevation/IL_Statewide_Lidar_DEM_WGS/ImageServer/WCSServer?request=GetCapabilities&amp;service=WCS&#39;

#Read study area shapefile (or other file) into geopandas
def read_study_area(studyareapath, crs=&#39;&#39;):
    &#34;&#34;&#34;Read study area geospatial file into geopandas

    Parameters
    ----------
    studyareapath : str or pathlib.Path
        Filepath to any geospatial file readable by geopandas. 
        Polygon is best, but may work with other types if extent is correct.
    crs : str, tuple, dict, optional
        CRS designation readable by geopandas/pyproj

    Returns
    -------
    studyAreaIN : geopandas dataframe
        Geopandas dataframe with polygon geometry.
    &#34;&#34;&#34;
    studyAreaIN = gpd.read_file(studyareapath)
    return studyAreaIN


def coords2Geometry(df, xCol=&#39;LONGITUDE&#39;, yCol=&#39;LATITUDE&#39;, zCol=&#39;ELEV_FT&#39;, crs=&#39;EPSG:4269&#39;, useZ=False):
    &#39;&#39;&#39;
    
    Adds geometry to points with xy coordinates in the specified coordinate reference system.

            Parameters:
                    df (pandas dataframe): a Pandas dataframe containing points
                    xCol (str): Name of column holding x coordinate data in df
                    yCol (str): Name of column holding y coordinate data in df
                    zCol (str): Name of column holding z coordinate data in df
                    crs (str): Name of crs used for geometry
                    useZ (bool): Whether to use z column in calculation

            Returns:
                    gdf (geopandas dataframe): Geopandas dataframe with points and their geometry values

    &#39;&#39;&#39;

    ptCRS=crs

    x = df[xCol].to_numpy()
    y = df[yCol].to_numpy()
    z = df[zCol].to_numpy()

    #coords = pd.concat([y, x], axis=1)
    if useZ:
        df[&#34;geometry&#34;] = gpd.points_from_xy(x, y, z=z, crs=ptCRS)
    else:
        df[&#34;geometry&#34;] = gpd.points_from_xy(x, y, crs=ptCRS)
        
    gdf = gpd.GeoDataFrame(df, crs=ptCRS)
    return gdf

def clipHeader2StudyArea(studyarea, headerdata, headerCRS=&#39;EPSG:4269&#39;):
    &#39;&#39;&#39;
    
    Clips dataframe to only include things within study area.

            Parameters:
                    studyarea (geopandas dataframe): Inputs study area polygon
                    headerdata (geopandas dataframe): Inputs point data
                    headerCRS (str): Inputs crs to project study area to
            
            Returns:
                    headerDataClip (geopandas dataframe): Contains only points within the study area
    
    &#39;&#39;&#39;
    studyArea_4269 = studyarea.to_crs(headerCRS).copy()
    
    headerDataClip = gpd.clip(headerdata, studyArea_4269) #Data from table is in EPSG:4269, easier to just project study area to ensure data fit
    
    headerDataClip.reset_index(inplace=True, drop=True) #Reset index
    
    return headerDataClip

def sample_raster_points(raster, points_df, xCol=&#39;LONGITUDE&#39;, yCol=&#39;LATITUDE&#39;, newColName=&#39;SAMPLED&#39;, printouts=True):  
    &#34;&#34;&#34;Sample raster values to points from geopandas geodataframe.

    Parameters
    ----------
    raster : rioxarray data array
        Raster containing values to be sampled.
    points_df : geopandas.geodataframe
        Geopandas dataframe with geometry column containing point values to sample.
    xCol : str, default=&#39;LONGITUDE&#39;
        Column containing name for x-column, by default &#39;LONGITUDE.&#39;
        This is used to output (potentially) reprojected point coordinates so as not to overwrite the original.
    yCol : str, default=&#39;LATITUDE&#39;
        Column containing name for y-column, by default &#39;LATITUDE.&#39;
        This is used to output (potentially) reprojected point coordinates so as not to overwrite the original.    newColName : str, optional
    newColName : str, default=&#39;SAMPLED&#39;
        Name for name of new column containing points sampled from the raster, by default &#39;SAMPLED&#39;.
    printouts : bool, default=True
        Whether to send to print() information about progress of function, by default True.

    Returns
    -------
    points_df : geopandas.geodataframe
        Same as points_df, but with sampled values and potentially with reprojected coordinates.
    &#34;&#34;&#34;
    if printouts:
        nowTime = datetime.datetime.now()
        expectMin = (points_df.shape[0]/3054409) * 14
        endTime = nowTime+datetime.timedelta(minutes=expectMin)
        print(newColName+ &#34; sampling should be done by {:d}:{:02d}&#34;.format(endTime.hour, endTime.minute))

    #Project points to raster CRS
    rastercrsWKT=raster.spatial_ref.crs_wkt
    points_df = points_df.to_crs(rastercrsWKT)
    #if xCol==&#39;LONGITUDE&#39; and yCol==&#39;LATITUDE&#39;:
    xCOLOUT = xCol+&#39;_PROJ&#39;
    yCOLOUT = yCol+&#39;_PROJ&#39;
    points_df[xCOLOUT] = points_df[&#39;geometry&#39;].x
    points_df[yCOLOUT] = points_df[&#39;geometry&#39;].y
    xData = np.array(points_df[xCOLOUT].values)
    yData = np.array(points_df[yCOLOUT].values)
    sampleArr=raster.sel(x=xData, y=yData, method=&#39;nearest&#39;).values
    sampleArr = np.diag(sampleArr)
    sampleDF = pd.DataFrame(sampleArr, columns=[newColName])
    points_df[newColName] = sampleDF[newColName]
    return points_df

def addElevtoHeader(xyz, header):
    &#39;&#39;&#39;
    
    Adds elevation to header data file.

            Parameters:
                    xyz (pandas dataframe): Contains elevation for the points
                    header (pandas dataframe): Header data file
                
            Returns:
                    headerXYZData (pandas dataframe): Header dataset merged to get elevation values
    
    &#39;&#39;&#39;
    headerXYZData = header.merge(xyz, how=&#39;left&#39;, on=&#39;API_NUMBER&#39;)
    headerXYZData.drop([&#39;LATITUDE_x&#39;, &#39;LONGITUDE_x&#39;], axis=1, inplace=True)
    headerXYZData.rename({&#39;LATITUDE_y&#39;:&#39;LATITUDE&#39;, &#39;LONGITUDE_y&#39;:&#39;LONGITUDE&#39;}, axis=1, inplace=True)
    return headerXYZData

def readWCS(studyArea, wcs_url=lidarURL, res_x=30, res_y=30, **kwargs):
    &#39;&#39;&#39;
    
    Reads a WebCoverageService from a url and returns a rioxarray dataset containing it.

            Parameters:
                    studyArea (list): A list of integers representing a bounding box
                    wcs_url (str): A string representing the url for the WCS
                    res_x (int): An integer to set resolution for x axis
                    res_y (int): An integer to set resolution for y axis
            
            Returns:
                    wcsData_rxr (xarray dataarray): A xarray dataarray holding the image from the WebCoverageService


    &#39;&#39;&#39;
    #Drawn largely from: https://git.wur.nl/isric/soilgrids/soilgrids.notebooks/-/blob/master/01-WCS-basics.ipynb
    
    #30m DEM
    #wcs_url = r&#39;https://data.isgs.illinois.edu/arcgis/services/Elevation/IL_DEM_30M/ImageServer/WCSServer?request=GetCapabilities&amp;service=WCS&#39;
    #lidar url:
    #lidarURL = r&#39;https://data.isgs.illinois.edu/arcgis/services/Elevation/IL_Statewide_Lidar_DEM_WGS/ImageServer/WCSServer?request=GetCapabilities&amp;service=WCS&#39;

    #studyAreaPath = r&#34;\\isgs-sinkhole.ad.uillinois.edu\geophysics\Balikian\ISWS_HydroGeo\WellDataAutoClassification\SampleData\ESL_StudyArea_5mi.shp&#34;
    #studyArea = gpd.read_file(studyAreaPath)

    if &#39;wcs_url&#39; in kwargs:
        wcs_url = kwargs[&#39;wcs_url&#39;]
    if &#39;res_x&#39; in kwargs:
        res_x = kwargs[&#39;res_x&#39;]
    if &#39;res_y&#39; in kwargs:
        res_y = kwargs[&#39;res_y&#39;]
    
    width_in = &#39;&#39;
    height_in= &#39;&#39;

    #Create coverage object
    my_wcs = WebCoverageService(wcs_url, version=&#39;1.0.0&#39;) 
    #names = [k for k in my_wcs.contents.keys()]
    #print(names)
    dataID = &#39;IL_Statewide_Lidar_DEM&#39;
    data = my_wcs.contents[dataID]
    dBBox = data.boundingboxes #Is this an error?
    
    studyArea = studyArea.to_crs(data.boundingboxes[0][&#39;nativeSrs&#39;])
    saBBox = studyArea.total_bounds
    
    #In case study area bounding box goes outside data bounding box, use data bounding box values
    newBBox = []
    for i,c in enumerate(dBBox[0][&#39;bbox&#39;]):
        if i == 0 or i==2:
            if saBBox[i] &lt; c:
                newBBox.append(saBBox[i])
            else:
                newBBox.append(c)
        else:
            if saBBox[i] &gt; c:
                newBBox.append(saBBox[i])
            else:
                newBBox.append(c)

    #Recalculate resolution if it is too fine to read in
    #Start by getting the area of the study area bounding box
    saWidth = saBBox[2]-saBBox[0]
    saHeight = saBBox[3]-saBBox[1]
    saBBoxAreaM = saWidth*saHeight
    saBBoxAreaKM = saBBoxAreaM/(1000*1000) #Area in km^2

    if saBBoxAreaM/(res_x*res_y) &gt; (4100*15000)*0.457194: #What I think might be the max download size?
        print(&#34;Resolution inputs overriden, file request too large.&#34;)
        res_x=str(round(saWidth/2500, 2))

        width_in  = str(int(saWidth/float(res_x )))
        height_in = str(int(saHeight/float(res_x)))
        
        res_y=str(round(saHeight/height_in, 2))

        print(&#39;New resolution is: &#39;+res_x+&#39;m_x X &#39;+res_y+&#39;m_y&#39; )
        print(&#39;Dataset size: &#39;+width_in+&#39; pixels_x X &#39;+height_in+&#39; pixels_y&#39;)

    bBox = tuple(newBBox)
    bBox_str = str(tuple(newBBox)[1:-1]).replace(&#39; &#39;,&#39;&#39;)
    dataCRS = &#39;EPSG:3857&#39;

    #Format WCS request using owslib
    response = my_wcs.getCoverage(
        identifier=my_wcs[dataID].id, 
        crs=dataCRS,#&#39;urn:ogc:def:crs:EPSG::26716&#39;,
        bbox=bBox,
        resx=res_x, 
        resy=res_y,
        timeout=60,
        #width = width_in, height=height_in,
        format=&#39;GeoTIFF&#39;)
    response

    #If I can figure out url, this might be better?
    #baseURL = r&#39;https://data.isgs.illinois.edu/arcgis/services/Elevation/&#39;+dataID+&#39;/ImageServer/WCSServer&#39;
    #addonRequestURL = &#39;?request=GetCoverage&amp;service=WCS&amp;bbox=&#39;+bBox_str+&#39;&amp;srs=&#39;+dataCRS+&#39;&amp;format=GeoTIFF&#39;+&#39;&amp;WIDTH=&#39;+width_in+&#39;&amp;HEIGHT=&#39;+height_in+&#39;)&#39;
    #reqURL = baseURL+addonRequestURL
    #wcsData_rxr =  rxr.open_rasterio(reqURL)

    with MemoryFile(response) as memfile:
        with memfile.open() as dataset:
            wcsData_rxr =  rxr.open_rasterio(dataset)

    return wcsData_rxr

def readWMS(study_area, layer_name=&#39;IL_Statewide_Lidar_DEM_WGS:None&#39;, wms_url=lidarURL, srs=&#39;EPSG:3857&#39;, clip_to_studyarea=True, bbox=[-9889002.615500,5134541.069716,-9737541.607038,5239029.627400],res_x=30, res_y=30, size_x=512, size_y=512, format=&#39;image/tiff&#39;, **kwargs):
    &#39;&#39;&#39;
    Reads a WebMapService from a url and returns a rioxarray dataset containing it.

            Parameters:
                    study_area (list): A list of integers representing a bounding box
                    layer_name (str): A string representing the layer name in the WMS
                    wms_url (str): A string representing the url for the WMS
                    res_x (int): An integer to set resolution for x axis
                    res_y (int): An integer to set resolution for y axis
                    size_x (int): An integer to set width of result
                    size_y (int): An integer to set height of result
            
            Returns:
                    wmsData_rxr (xarray dataarray): A xarray dataarray holding the image from the WebMapService
    &#39;&#39;&#39;
    from owslib.wms import WebMapService
    # Define WMS endpoint URL
    if &#39;wms_url&#39; in kwargs:
        wms_url = kwargs[&#39;wms_url&#39;]
    else:
        wms_url = wms_url
    # Create WMS connection object
    wms = WebMapService(wms_url)
    # Print available layers
    #print(wms.contents)
    # Select desired layer
    if &#39;layer_name&#39; in kwargs:
        layer = kwargs[&#39;layer_name&#39;]
    else:
        layer = layer_name
    
    data = wms.contents#[layer]
    print(data[&#39;0&#39;].__dict__)
    if &#39;srs&#39; in kwargs:
        studyArea_proj = study_area.to_crs(kwargs[&#39;srs&#39;])
        saBBox = studyArea_proj.total_bounds
    else:
        studyArea_proj = study_area.to_crs(srs)
    
    saBBox = studyArea_proj.total_bounds

    if layer == &#39;IL_Statewide_Lidar_DEM_WGS:None&#39;:
        dBBox = data[&#39;0&#39;].boundingBox #Is this an error?
        print(dBBox)

        gpdDict = {&#39;Label&#39;: [&#39;Surf Data Box&#39;], &#39;geometry&#39;: [shapely.geometry.Polygon(((dBBox[0], dBBox[1]), (dBBox[0], dBBox[3]), (dBBox[2], dBBox[3]), (dBBox[2], dBBox[1]), (dBBox[0], dBBox[1])))]}
        dBBoxGDF = gpd.GeoDataFrame(gpdDict, crs=dBBox[4])
        dBBoxGDF.to_crs(srs)
        #In case study area bounding box goes outside data bounding box, use data bounding box values
        newBBox = []
        for i,c in enumerate(dBBox):
            if type(c) is str:
                pass
            elif i == 0 or i==2:
                if saBBox[i] &lt; c:
                    newBBox.append(saBBox[i])
                else:
                    newBBox.append(c)
            else:
                if saBBox[i] &gt; c:
                    newBBox.append(saBBox[i])
                else:
                    newBBox.append(c)

    saWidth = saBBox[2]-saBBox[0]
    saHeight = saBBox[3]-saBBox[1]    
    print(&#39;Done with bbx&#39;)
    # Check kwargs for rest of parameters
    if &#39;size_x&#39; in kwargs:
        size_x = kwargs[&#39;size_x&#39;]
    if &#39;size_y&#39; in kwargs:
        size_y = kwargs[&#39;size_y&#39;]
    if &#39;format&#39; in kwargs:
        format = kwargs[&#39;format&#39;]
    if &#39;clip_to_studyarea&#39; in kwargs:
        clip_to_studyarea = kwargs[&#39;clip_to_studyarea&#39;]
    #get the wms
    print(saBBox)

    if clip_to_studyarea:
        img = wms.getmap(layers=[layer], srs=srs, bbox=saBBox, size=(size_x, size_y), format=format, transparent=True, timeout=60)        
    else:
        img = wms.getmap(layers=[layer], srs=srs, bbox=bbox, size=(size_x, size_y), format=format, transparent=True, timeout=60)
    print(&#39;Done with getmap&#39;)

    #with open(&#39;statewide_test.tiff&#39;, &#39;wb&#39;) as f: 
    #    f.write(img.read())
    #Save wms in memory to a raster dataset
    with MemoryFile(img) as memfile:
        with memfile.open() as dataset:
            wmsData_rxr = rxr.open_rasterio(dataset)

    #if clip_to_studyarea:
    #    wmsData_rxr = wmsData_rxr.sel(x=slice(saBBox[0], saBBox[2]), y=slice(saBBox[3], saBBox[1]))#.sel(band=1)

    return wmsData_rxr

def clipGrid2StudyArea(studyArea, grid, studyAreacrs=&#39;&#39;, gridcrs=&#39;&#39;):
    &#39;&#39;&#39;
    
    Clips grid to study area.

            Parameters:
                    studyArea (geopandas dataframe): inputs study area polygon
                    grid (xarray dataarray): inputs grid array
                    studyAreacrs (str): inputs the coordinate reference system for the study area
                    gridcrs (str): inputs the coordinate reference system for the grid
            
            Returns:
                    grid (xarray dataarray): returns xarray containing grid clipped only to area within study area

    &#39;&#39;&#39;
    
    if studyAreacrs==&#39;&#39;:
        studyAreacrs=studyArea.crs

    if gridcrs==&#39;&#39;:
        #Get EPSG of model grid
        subtext = grid.spatial_ref.crs_wkt[-20:]
        starInd = subtext.find(&#39;EPSG&#39;)
        gridcrs = subtext[starInd:-2].replace(&#39;&#34;&#39;,&#39;&#39;).replace(&#39;,&#39;,&#39;:&#39;)   
        #print(gridcrs)
    
    if studyAreacrs != gridcrs:
        studyAreaUnproject = studyArea.copy()
        studyArea = studyArea.to_crs(gridcrs)   
    else:
        studyArea = studyArea

    saExtent = studyArea.total_bounds

    if grid[&#39;y&#39;][-1].values - grid[&#39;y&#39;][0].values &gt; 0:
        miny=saExtent[1]
        maxy=saExtent[3]
    else:
        miny=saExtent[3]
        maxy=saExtent[1]        
        
    if grid[&#39;x&#39;][-1].values - grid[&#39;x&#39;][0].values &gt; 0:
        minx=saExtent[0]
        maxx=saExtent[2]
    else:
        minx=saExtent[2]
        maxx=saExtent[0]
    grid = grid.sel(x=slice(minx, maxx), y=slice(miny, maxy)).sel(band=1)     

    return grid


def read_model_grid(studyArea, gridpath, nodataval=0, read_grid=True, node_bySpace=False, clip2SA=True, studyAreacrs=None, gridcrs=None):
    &#34;&#34;&#34;_summary_

    Parameters
    ----------
    studyArea : _type_
        _description_
    gridpath : _type_
        _description_
    nodataval : int, optional
        _description_, by default 0
    readGrid : bool, optional
        _description_, by default True
    node_bySpace : bool, optional
        _description_, by default False
    clip2SA : bool, optional
        _description_, by default True
    studyAreacrs : str, optional
        _description_, by default &#39;&#39;
    gridcrs : str, optional
        _description_, by default &#39;&#39;

    Returns
    -------
    _type_
        _description_
    &#34;&#34;&#34;
    read_grid = True
    node_bySpace = False #False means by number of nodes
    
    if read_grid:
        modelGridIN = rxr.open_rasterio(gridpath)

        file = w4h.get_resource_path(&#39;isws_crs.txt&#39;)
        iswsCRS = w4h.read_dict(file, keytype=None)

        if gridcrs is None:
            try:
                gridcrs=modelGridIN.spatial_ref.crs_wkt
            except:
                modelGridIN.rio.write_crs(iswsCRS)
        elif gridcrs.lower()==&#39;isws&#39;:
            modelGridIN.rio.write_crs(iswsCRS)
        
        if clip2SA:                
            if studyAreacrs is None:
                studyAreacrs=studyArea.crs
            studyArea = studyArea.to_crs(gridcrs)
            studyAreacrs=studyArea.crs            
            modelGrid = clipGrid2StudyArea(studyArea=studyArea, grid=modelGridIN, studyAreacrs=studyAreacrs, gridcrs=gridcrs)
        try:
            noDataVal = float(modelGrid.attrs[&#39;_FillValue&#39;]) #Extract from dataset itsel
        except:
            noDataVal = -5000000

        modelGrid = modelGrid.where(modelGrid != noDataVal, other=np.nan)   #Replace no data values with NaNs
        modelGrid.rio.reproject(iswsCRS, inplace=True)
    else:
        spatRefDict = {&#39;crs_wkt&#39;: &#39;PROJCS[&#34;Clarke_1866_Lambert_Conformal_Conic&#34;,GEOGCS[&#34;NAD27&#34;,DATUM[&#34;North_American_Datum_1927&#34;,SPHEROID[&#34;Clarke 1866&#34;,6378206.4,294.978698199999,AUTHORITY[&#34;EPSG&#34;,&#34;7008&#34;]],AUTHORITY[&#34;EPSG&#34;,&#34;6267&#34;]],PRIMEM[&#34;Greenwich&#34;,0],UNIT[&#34;degree&#34;,0.0174532925199433,AUTHORITY[&#34;EPSG&#34;,&#34;9122&#34;]],AUTHORITY[&#34;EPSG&#34;,&#34;4267&#34;]],PROJECTION[&#34;Lambert_Conformal_Conic_2SP&#34;],PARAMETER[&#34;latitude_of_origin&#34;,33],PARAMETER[&#34;central_meridian&#34;,-89.5],PARAMETER[&#34;standard_parallel_1&#34;,33],PARAMETER[&#34;standard_parallel_2&#34;,45],PARAMETER[&#34;false_easting&#34;,2999994],PARAMETER[&#34;false_northing&#34;,0],UNIT[&#34;US survey foot&#34;,0.304800609601219,AUTHORITY[&#34;EPSG&#34;,&#34;9003&#34;]],AXIS[&#34;Easting&#34;,EAST],AXIS[&#34;Northing&#34;,NORTH]]&#39;,
            &#39;semi_major_axis&#39;: 6378206.4,
            &#39;semi_minor_axis&#39;: 6356583.799998981,
            &#39;inverse_flattening&#39;: 294.978698199999,
            &#39;reference_ellipsoid_name&#39;: &#39;Clarke 1866&#39;,
            &#39;longitude_of_prime_meridian&#39;: 0.0,
            &#39;prime_meridian_name&#39;: &#39;Greenwich&#39;,
            &#39;geographic_crs_name&#39;: &#39;NAD27&#39;,
            &#39;horizontal_datum_name&#39;: &#39;North American Datum 1927&#39;,
            &#39;projected_crs_name&#39;: &#39;Clarke_1866_Lambert_Conformal_Conic&#39;,
            &#39;grid_mapping_name&#39;: &#39;lambert_conformal_conic&#39;,
            &#39;standard_parallel&#39;: (33.0, 45.0),
            &#39;latitude_of_projection_origin&#39;: 33.0,
            &#39;longitude_of_central_meridian&#39;: -89.5,
            &#39;false_easting&#39;: 2999994.0,
            &#39;false_northing&#39;: 0.0,
            &#39;spatial_ref&#39;: &#39;PROJCS[&#34;Clarke_1866_Lambert_Conformal_Conic&#34;,GEOGCS[&#34;NAD27&#34;,DATUM[&#34;North_American_Datum_1927&#34;,SPHEROID[&#34;Clarke 1866&#34;,6378206.4,294.978698199999,AUTHORITY[&#34;EPSG&#34;,&#34;7008&#34;]],AUTHORITY[&#34;EPSG&#34;,&#34;6267&#34;]],PRIMEM[&#34;Greenwich&#34;,0],UNIT[&#34;degree&#34;,0.0174532925199433,AUTHORITY[&#34;EPSG&#34;,&#34;9122&#34;]],AUTHORITY[&#34;EPSG&#34;,&#34;4267&#34;]],PROJECTION[&#34;Lambert_Conformal_Conic_2SP&#34;],PARAMETER[&#34;latitude_of_origin&#34;,33],PARAMETER[&#34;central_meridian&#34;,-89.5],PARAMETER[&#34;standard_parallel_1&#34;,33],PARAMETER[&#34;standard_parallel_2&#34;,45],PARAMETER[&#34;false_easting&#34;,2999994],PARAMETER[&#34;false_northing&#34;,0],UNIT[&#34;US survey foot&#34;,0.304800609601219,AUTHORITY[&#34;EPSG&#34;,&#34;9003&#34;]],AXIS[&#34;Easting&#34;,EAST],AXIS[&#34;Northing&#34;,NORTH]]&#39;,
            &#39;GeoTransform&#39;: &#39;2440250.0 625.0 0.0 3459750.0 0.0 -625.0&#39;}
        
        saExtent = studyArea.total_bounds

        startX = saExtent[0] #Starting X Coordinate
        startY = saExtent[1] #starting Y Coordinate
        
        endX = saExtent[2]
        endY = saExtent[3]
        
        if node_bySpace:
            xSpacing = 625 #X Node spacing 
            ySpacing = xSpacing #Y Node spacing  
            
            x = np.arange(startX, endX, xSpacing)
            y = np.arange(startY, endY, ySpacing)
        else:
            xNodes = 100 #Number of X Nodes
            yNodes = 100 #Number of Y Nodes

            x = np.linspace(startX, endX, num=xNodes)
            y = np.linspace(startY, endY, num=yNodes)        
        
        xx, yy = np.meshgrid(x, y)
        zz = np.ones_like(xx).transpose()

        yIn = np.flipud(y)

        coords = {&#39;x&#39;:x,&#39;y&#39;:yIn, &#39;spatial_ref&#39;:0}
        dims = {&#39;x&#39;:x,&#39;y&#39;:yIn}
        
        modelGrid = xr.DataArray(data=zz,coords=coords,attrs={&#39;_FillValue&#39;:3.402823466e+38}, dims=dims)
        modelGrid.spatial_ref.attrs[&#39;spatial_ref&#39;] = {}
        if gridcrs is None or gridcrs==&#39;isws&#39; or gridcrs==&#39;ISWS&#39;:
            for k in spatRefDict:
                modelGrid.spatial_ref.attrs[k] = spatRefDict[k]
    return modelGrid

def read_grid(datapath=&#39;&#39;, grid_type=&#39;model&#39;, nodataval=0, use_service=False, studyArea=&#39;&#39;, clip2SA=True,  studyAreacrs=None, gridcrs=None, **kwargs):
    if grid_type==&#39;model&#39;:
        if &#39;read_grid&#39; in list(kwargs.keys()):
            rgrid = kwargs[&#39;read_grid&#39;]
        else:
            rgrid=True
        gridIN = read_model_grid(studyArea, gridpath=datapath, nodataval=0, read_grid=rgrid, clip2SA=clip2SA, studyAreacrs=studyAreacrs, gridcrs=gridcrs)
    else:
        if use_service==False:
            gridIN = rxr.open_rasterio(datapath)
        elif use_service.lower()==&#39;wcs&#39;:
            gridIN = readWCS(studyArea, wcs_url=lidarURL, **kwargs)
        elif use_service.lower()==&#39;wms&#39;:
            pass
            gridIN = readWMS(studyArea, wcs_url=lidarURL, **kwargs)
            
        if clip2SA:
            if gridcrs is None:
                try:
                    gridcrs=gridIN.spatial_ref.crs_wkt
                except:
                    iswsCRS = w4h.read_dict(r&#39;../resources/isws_crs&#39;)
                    gridIN.rio.write_crs(iswsCRS)
            elif gridcrs.lower()==&#39;isws&#39;:
                iswsCRS = w4h.read_dict(r&#39;../resources/isws_crs&#39;)
                gridIN.rio.write_crs(iswsCRS)
                
            if studyAreacrs is None:
                studyAreacrs=studyArea.crs
            studyArea = studyArea.to_crs(gridcrs)
            studyAreacrs=studyArea.crs
            
            gridIN = clipGrid2StudyArea(studyArea=studyArea, grid=gridIN, studyAreacrs=studyAreacrs, gridcrs=gridcrs)
        try:
            nodataval = gridIN.attrs[&#39;_FillValue&#39;] #Extract from dataset itself
        except:
            pass
                
        gridIN = gridIN.where(gridIN != nodataval, other=np.nan)  #Replace no data values with NaNs

    return gridIN

def alignRasters(unalignedGrids, modelgrid, nodataval=0):
    
    if type(unalignedGrids) is list:
        alignedGrids=[]
        for g in unalignedGrids:
            alignedGrid = g.rio.reproject_match(modelgrid)

            try:
                nodataval = alignedGrid.attrs[&#39;_FillValue&#39;] #Extract from dataset itself
            except:
                pass
            
            alignedGrid = alignedGrid.where(alignedGrid != nodataval)  #Replace no data values with NaNs
            
            alignedGrids.append(alignedGrid)
    else:
        alignedGrid = unalignedGrids.rio.reproject_match(modelgrid)

        try:
            noDataVal = alignedGrid.attrs[&#39;_FillValue&#39;] #Extract from dataset itself
        except:
            pass

        alignedGrids = alignedGrid.where(alignedGrid != noDataVal, other=np.nan)  #Replace no data values with NaNs
        
    return alignedGrids

def get_drift_thick(surface, bedrock, noLayers=9, plotData=False):
    &#39;&#39;&#39;
    
    Finds the distance from surface to bedrock and then divides by number of layers to get layer thickness.

            Parameters:
                    surface (rioxarray dataarray): array holding surface elevation
                    bedrock (rioxarray dataarray): array holding bedrock elevation
                    noLayers (int): number of layers needed to calculate thickness for
                    plotData (bool): tells function to either plot the data or not

            Returns:
                    driftThick (rioxarray dataarray): Contains data array containing depth to bedrock at each point
                    layerThick (rioxarray dataarray): Contains data array with layer thickness at each point
    
    &#39;&#39;&#39;
    xr.set_options(keep_attrs=True)

    driftThick = surface - bedrock
    driftThick = driftThick.clip(0,max=5000,keep_attrs=True)
    if plotData:
        driftThick.plot()

    try:
        noDataVal = driftThick.attrs[&#39;_FillValue&#39;] #Extract from dataset itself
    except:
        noDataVal = 100001
    


    driftThick = driftThick.where(driftThick &lt;100000, other=np.nan)  #Replace no data values with NaNs
    driftThick = driftThick.where(driftThick &gt;-100000, other=np.nan)  #Replace no data values with NaNs

    layerThick = driftThick/noLayers
    
    xr.set_options(keep_attrs=&#39;default&#39;)

    return driftThick, layerThick
    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="w4h.mapping.addElevtoHeader"><code class="name flex">
<span>def <span class="ident">addElevtoHeader</span></span>(<span>xyz, header)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds elevation to header data file.</p>
<pre><code>    Parameters:
            xyz (pandas dataframe): Contains elevation for the points
            header (pandas dataframe): Header data file

    Returns:
            headerXYZData (pandas dataframe): Header dataset merged to get elevation values
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addElevtoHeader(xyz, header):
    &#39;&#39;&#39;
    
    Adds elevation to header data file.

            Parameters:
                    xyz (pandas dataframe): Contains elevation for the points
                    header (pandas dataframe): Header data file
                
            Returns:
                    headerXYZData (pandas dataframe): Header dataset merged to get elevation values
    
    &#39;&#39;&#39;
    headerXYZData = header.merge(xyz, how=&#39;left&#39;, on=&#39;API_NUMBER&#39;)
    headerXYZData.drop([&#39;LATITUDE_x&#39;, &#39;LONGITUDE_x&#39;], axis=1, inplace=True)
    headerXYZData.rename({&#39;LATITUDE_y&#39;:&#39;LATITUDE&#39;, &#39;LONGITUDE_y&#39;:&#39;LONGITUDE&#39;}, axis=1, inplace=True)
    return headerXYZData</code></pre>
</details>
</dd>
<dt id="w4h.mapping.alignRasters"><code class="name flex">
<span>def <span class="ident">alignRasters</span></span>(<span>unalignedGrids, modelgrid, nodataval=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def alignRasters(unalignedGrids, modelgrid, nodataval=0):
    
    if type(unalignedGrids) is list:
        alignedGrids=[]
        for g in unalignedGrids:
            alignedGrid = g.rio.reproject_match(modelgrid)

            try:
                nodataval = alignedGrid.attrs[&#39;_FillValue&#39;] #Extract from dataset itself
            except:
                pass
            
            alignedGrid = alignedGrid.where(alignedGrid != nodataval)  #Replace no data values with NaNs
            
            alignedGrids.append(alignedGrid)
    else:
        alignedGrid = unalignedGrids.rio.reproject_match(modelgrid)

        try:
            noDataVal = alignedGrid.attrs[&#39;_FillValue&#39;] #Extract from dataset itself
        except:
            pass

        alignedGrids = alignedGrid.where(alignedGrid != noDataVal, other=np.nan)  #Replace no data values with NaNs
        
    return alignedGrids</code></pre>
</details>
</dd>
<dt id="w4h.mapping.clipGrid2StudyArea"><code class="name flex">
<span>def <span class="ident">clipGrid2StudyArea</span></span>(<span>studyArea, grid, studyAreacrs='', gridcrs='')</span>
</code></dt>
<dd>
<div class="desc"><p>Clips grid to study area.</p>
<pre><code>    Parameters:
            studyArea (geopandas dataframe): inputs study area polygon
            grid (xarray dataarray): inputs grid array
            studyAreacrs (str): inputs the coordinate reference system for the study area
            gridcrs (str): inputs the coordinate reference system for the grid

    Returns:
            grid (xarray dataarray): returns xarray containing grid clipped only to area within study area
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clipGrid2StudyArea(studyArea, grid, studyAreacrs=&#39;&#39;, gridcrs=&#39;&#39;):
    &#39;&#39;&#39;
    
    Clips grid to study area.

            Parameters:
                    studyArea (geopandas dataframe): inputs study area polygon
                    grid (xarray dataarray): inputs grid array
                    studyAreacrs (str): inputs the coordinate reference system for the study area
                    gridcrs (str): inputs the coordinate reference system for the grid
            
            Returns:
                    grid (xarray dataarray): returns xarray containing grid clipped only to area within study area

    &#39;&#39;&#39;
    
    if studyAreacrs==&#39;&#39;:
        studyAreacrs=studyArea.crs

    if gridcrs==&#39;&#39;:
        #Get EPSG of model grid
        subtext = grid.spatial_ref.crs_wkt[-20:]
        starInd = subtext.find(&#39;EPSG&#39;)
        gridcrs = subtext[starInd:-2].replace(&#39;&#34;&#39;,&#39;&#39;).replace(&#39;,&#39;,&#39;:&#39;)   
        #print(gridcrs)
    
    if studyAreacrs != gridcrs:
        studyAreaUnproject = studyArea.copy()
        studyArea = studyArea.to_crs(gridcrs)   
    else:
        studyArea = studyArea

    saExtent = studyArea.total_bounds

    if grid[&#39;y&#39;][-1].values - grid[&#39;y&#39;][0].values &gt; 0:
        miny=saExtent[1]
        maxy=saExtent[3]
    else:
        miny=saExtent[3]
        maxy=saExtent[1]        
        
    if grid[&#39;x&#39;][-1].values - grid[&#39;x&#39;][0].values &gt; 0:
        minx=saExtent[0]
        maxx=saExtent[2]
    else:
        minx=saExtent[2]
        maxx=saExtent[0]
    grid = grid.sel(x=slice(minx, maxx), y=slice(miny, maxy)).sel(band=1)     

    return grid</code></pre>
</details>
</dd>
<dt id="w4h.mapping.clipHeader2StudyArea"><code class="name flex">
<span>def <span class="ident">clipHeader2StudyArea</span></span>(<span>studyarea, headerdata, headerCRS='EPSG:4269')</span>
</code></dt>
<dd>
<div class="desc"><p>Clips dataframe to only include things within study area.</p>
<pre><code>    Parameters:
            studyarea (geopandas dataframe): Inputs study area polygon
            headerdata (geopandas dataframe): Inputs point data
            headerCRS (str): Inputs crs to project study area to

    Returns:
            headerDataClip (geopandas dataframe): Contains only points within the study area
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clipHeader2StudyArea(studyarea, headerdata, headerCRS=&#39;EPSG:4269&#39;):
    &#39;&#39;&#39;
    
    Clips dataframe to only include things within study area.

            Parameters:
                    studyarea (geopandas dataframe): Inputs study area polygon
                    headerdata (geopandas dataframe): Inputs point data
                    headerCRS (str): Inputs crs to project study area to
            
            Returns:
                    headerDataClip (geopandas dataframe): Contains only points within the study area
    
    &#39;&#39;&#39;
    studyArea_4269 = studyarea.to_crs(headerCRS).copy()
    
    headerDataClip = gpd.clip(headerdata, studyArea_4269) #Data from table is in EPSG:4269, easier to just project study area to ensure data fit
    
    headerDataClip.reset_index(inplace=True, drop=True) #Reset index
    
    return headerDataClip</code></pre>
</details>
</dd>
<dt id="w4h.mapping.coords2Geometry"><code class="name flex">
<span>def <span class="ident">coords2Geometry</span></span>(<span>df, xCol='LONGITUDE', yCol='LATITUDE', zCol='ELEV_FT', crs='EPSG:4269', useZ=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds geometry to points with xy coordinates in the specified coordinate reference system.</p>
<pre><code>    Parameters:
            df (pandas dataframe): a Pandas dataframe containing points
            xCol (str): Name of column holding x coordinate data in df
            yCol (str): Name of column holding y coordinate data in df
            zCol (str): Name of column holding z coordinate data in df
            crs (str): Name of crs used for geometry
            useZ (bool): Whether to use z column in calculation

    Returns:
            gdf (geopandas dataframe): Geopandas dataframe with points and their geometry values
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coords2Geometry(df, xCol=&#39;LONGITUDE&#39;, yCol=&#39;LATITUDE&#39;, zCol=&#39;ELEV_FT&#39;, crs=&#39;EPSG:4269&#39;, useZ=False):
    &#39;&#39;&#39;
    
    Adds geometry to points with xy coordinates in the specified coordinate reference system.

            Parameters:
                    df (pandas dataframe): a Pandas dataframe containing points
                    xCol (str): Name of column holding x coordinate data in df
                    yCol (str): Name of column holding y coordinate data in df
                    zCol (str): Name of column holding z coordinate data in df
                    crs (str): Name of crs used for geometry
                    useZ (bool): Whether to use z column in calculation

            Returns:
                    gdf (geopandas dataframe): Geopandas dataframe with points and their geometry values

    &#39;&#39;&#39;

    ptCRS=crs

    x = df[xCol].to_numpy()
    y = df[yCol].to_numpy()
    z = df[zCol].to_numpy()

    #coords = pd.concat([y, x], axis=1)
    if useZ:
        df[&#34;geometry&#34;] = gpd.points_from_xy(x, y, z=z, crs=ptCRS)
    else:
        df[&#34;geometry&#34;] = gpd.points_from_xy(x, y, crs=ptCRS)
        
    gdf = gpd.GeoDataFrame(df, crs=ptCRS)
    return gdf</code></pre>
</details>
</dd>
<dt id="w4h.mapping.get_drift_thick"><code class="name flex">
<span>def <span class="ident">get_drift_thick</span></span>(<span>surface, bedrock, noLayers=9, plotData=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Finds the distance from surface to bedrock and then divides by number of layers to get layer thickness.</p>
<pre><code>    Parameters:
            surface (rioxarray dataarray): array holding surface elevation
            bedrock (rioxarray dataarray): array holding bedrock elevation
            noLayers (int): number of layers needed to calculate thickness for
            plotData (bool): tells function to either plot the data or not

    Returns:
            driftThick (rioxarray dataarray): Contains data array containing depth to bedrock at each point
            layerThick (rioxarray dataarray): Contains data array with layer thickness at each point
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_drift_thick(surface, bedrock, noLayers=9, plotData=False):
    &#39;&#39;&#39;
    
    Finds the distance from surface to bedrock and then divides by number of layers to get layer thickness.

            Parameters:
                    surface (rioxarray dataarray): array holding surface elevation
                    bedrock (rioxarray dataarray): array holding bedrock elevation
                    noLayers (int): number of layers needed to calculate thickness for
                    plotData (bool): tells function to either plot the data or not

            Returns:
                    driftThick (rioxarray dataarray): Contains data array containing depth to bedrock at each point
                    layerThick (rioxarray dataarray): Contains data array with layer thickness at each point
    
    &#39;&#39;&#39;
    xr.set_options(keep_attrs=True)

    driftThick = surface - bedrock
    driftThick = driftThick.clip(0,max=5000,keep_attrs=True)
    if plotData:
        driftThick.plot()

    try:
        noDataVal = driftThick.attrs[&#39;_FillValue&#39;] #Extract from dataset itself
    except:
        noDataVal = 100001
    


    driftThick = driftThick.where(driftThick &lt;100000, other=np.nan)  #Replace no data values with NaNs
    driftThick = driftThick.where(driftThick &gt;-100000, other=np.nan)  #Replace no data values with NaNs

    layerThick = driftThick/noLayers
    
    xr.set_options(keep_attrs=&#39;default&#39;)

    return driftThick, layerThick</code></pre>
</details>
</dd>
<dt id="w4h.mapping.readWCS"><code class="name flex">
<span>def <span class="ident">readWCS</span></span>(<span>studyArea, wcs_url='https://data.isgs.illinois.edu/arcgis/services/Elevation/IL_Statewide_Lidar_DEM_WGS/ImageServer/WCSServer?request=GetCapabilities&service=WCS', res_x=30, res_y=30, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads a WebCoverageService from a url and returns a rioxarray dataset containing it.</p>
<pre><code>    Parameters:
            studyArea (list): A list of integers representing a bounding box
            wcs_url (str): A string representing the url for the WCS
            res_x (int): An integer to set resolution for x axis
            res_y (int): An integer to set resolution for y axis

    Returns:
            wcsData_rxr (xarray dataarray): A xarray dataarray holding the image from the WebCoverageService
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def readWCS(studyArea, wcs_url=lidarURL, res_x=30, res_y=30, **kwargs):
    &#39;&#39;&#39;
    
    Reads a WebCoverageService from a url and returns a rioxarray dataset containing it.

            Parameters:
                    studyArea (list): A list of integers representing a bounding box
                    wcs_url (str): A string representing the url for the WCS
                    res_x (int): An integer to set resolution for x axis
                    res_y (int): An integer to set resolution for y axis
            
            Returns:
                    wcsData_rxr (xarray dataarray): A xarray dataarray holding the image from the WebCoverageService


    &#39;&#39;&#39;
    #Drawn largely from: https://git.wur.nl/isric/soilgrids/soilgrids.notebooks/-/blob/master/01-WCS-basics.ipynb
    
    #30m DEM
    #wcs_url = r&#39;https://data.isgs.illinois.edu/arcgis/services/Elevation/IL_DEM_30M/ImageServer/WCSServer?request=GetCapabilities&amp;service=WCS&#39;
    #lidar url:
    #lidarURL = r&#39;https://data.isgs.illinois.edu/arcgis/services/Elevation/IL_Statewide_Lidar_DEM_WGS/ImageServer/WCSServer?request=GetCapabilities&amp;service=WCS&#39;

    #studyAreaPath = r&#34;\\isgs-sinkhole.ad.uillinois.edu\geophysics\Balikian\ISWS_HydroGeo\WellDataAutoClassification\SampleData\ESL_StudyArea_5mi.shp&#34;
    #studyArea = gpd.read_file(studyAreaPath)

    if &#39;wcs_url&#39; in kwargs:
        wcs_url = kwargs[&#39;wcs_url&#39;]
    if &#39;res_x&#39; in kwargs:
        res_x = kwargs[&#39;res_x&#39;]
    if &#39;res_y&#39; in kwargs:
        res_y = kwargs[&#39;res_y&#39;]
    
    width_in = &#39;&#39;
    height_in= &#39;&#39;

    #Create coverage object
    my_wcs = WebCoverageService(wcs_url, version=&#39;1.0.0&#39;) 
    #names = [k for k in my_wcs.contents.keys()]
    #print(names)
    dataID = &#39;IL_Statewide_Lidar_DEM&#39;
    data = my_wcs.contents[dataID]
    dBBox = data.boundingboxes #Is this an error?
    
    studyArea = studyArea.to_crs(data.boundingboxes[0][&#39;nativeSrs&#39;])
    saBBox = studyArea.total_bounds
    
    #In case study area bounding box goes outside data bounding box, use data bounding box values
    newBBox = []
    for i,c in enumerate(dBBox[0][&#39;bbox&#39;]):
        if i == 0 or i==2:
            if saBBox[i] &lt; c:
                newBBox.append(saBBox[i])
            else:
                newBBox.append(c)
        else:
            if saBBox[i] &gt; c:
                newBBox.append(saBBox[i])
            else:
                newBBox.append(c)

    #Recalculate resolution if it is too fine to read in
    #Start by getting the area of the study area bounding box
    saWidth = saBBox[2]-saBBox[0]
    saHeight = saBBox[3]-saBBox[1]
    saBBoxAreaM = saWidth*saHeight
    saBBoxAreaKM = saBBoxAreaM/(1000*1000) #Area in km^2

    if saBBoxAreaM/(res_x*res_y) &gt; (4100*15000)*0.457194: #What I think might be the max download size?
        print(&#34;Resolution inputs overriden, file request too large.&#34;)
        res_x=str(round(saWidth/2500, 2))

        width_in  = str(int(saWidth/float(res_x )))
        height_in = str(int(saHeight/float(res_x)))
        
        res_y=str(round(saHeight/height_in, 2))

        print(&#39;New resolution is: &#39;+res_x+&#39;m_x X &#39;+res_y+&#39;m_y&#39; )
        print(&#39;Dataset size: &#39;+width_in+&#39; pixels_x X &#39;+height_in+&#39; pixels_y&#39;)

    bBox = tuple(newBBox)
    bBox_str = str(tuple(newBBox)[1:-1]).replace(&#39; &#39;,&#39;&#39;)
    dataCRS = &#39;EPSG:3857&#39;

    #Format WCS request using owslib
    response = my_wcs.getCoverage(
        identifier=my_wcs[dataID].id, 
        crs=dataCRS,#&#39;urn:ogc:def:crs:EPSG::26716&#39;,
        bbox=bBox,
        resx=res_x, 
        resy=res_y,
        timeout=60,
        #width = width_in, height=height_in,
        format=&#39;GeoTIFF&#39;)
    response

    #If I can figure out url, this might be better?
    #baseURL = r&#39;https://data.isgs.illinois.edu/arcgis/services/Elevation/&#39;+dataID+&#39;/ImageServer/WCSServer&#39;
    #addonRequestURL = &#39;?request=GetCoverage&amp;service=WCS&amp;bbox=&#39;+bBox_str+&#39;&amp;srs=&#39;+dataCRS+&#39;&amp;format=GeoTIFF&#39;+&#39;&amp;WIDTH=&#39;+width_in+&#39;&amp;HEIGHT=&#39;+height_in+&#39;)&#39;
    #reqURL = baseURL+addonRequestURL
    #wcsData_rxr =  rxr.open_rasterio(reqURL)

    with MemoryFile(response) as memfile:
        with memfile.open() as dataset:
            wcsData_rxr =  rxr.open_rasterio(dataset)

    return wcsData_rxr</code></pre>
</details>
</dd>
<dt id="w4h.mapping.readWMS"><code class="name flex">
<span>def <span class="ident">readWMS</span></span>(<span>study_area, layer_name='IL_Statewide_Lidar_DEM_WGS:None', wms_url='https://data.isgs.illinois.edu/arcgis/services/Elevation/IL_Statewide_Lidar_DEM_WGS/ImageServer/WCSServer?request=GetCapabilities&service=WCS', srs='EPSG:3857', clip_to_studyarea=True, bbox=[-9889002.6155, 5134541.069716, -9737541.607038, 5239029.6274], res_x=30, res_y=30, size_x=512, size_y=512, format='image/tiff', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads a WebMapService from a url and returns a rioxarray dataset containing it.</p>
<pre><code>    Parameters:
            study_area (list): A list of integers representing a bounding box
            layer_name (str): A string representing the layer name in the WMS
            wms_url (str): A string representing the url for the WMS
            res_x (int): An integer to set resolution for x axis
            res_y (int): An integer to set resolution for y axis
            size_x (int): An integer to set width of result
            size_y (int): An integer to set height of result

    Returns:
            wmsData_rxr (xarray dataarray): A xarray dataarray holding the image from the WebMapService
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def readWMS(study_area, layer_name=&#39;IL_Statewide_Lidar_DEM_WGS:None&#39;, wms_url=lidarURL, srs=&#39;EPSG:3857&#39;, clip_to_studyarea=True, bbox=[-9889002.615500,5134541.069716,-9737541.607038,5239029.627400],res_x=30, res_y=30, size_x=512, size_y=512, format=&#39;image/tiff&#39;, **kwargs):
    &#39;&#39;&#39;
    Reads a WebMapService from a url and returns a rioxarray dataset containing it.

            Parameters:
                    study_area (list): A list of integers representing a bounding box
                    layer_name (str): A string representing the layer name in the WMS
                    wms_url (str): A string representing the url for the WMS
                    res_x (int): An integer to set resolution for x axis
                    res_y (int): An integer to set resolution for y axis
                    size_x (int): An integer to set width of result
                    size_y (int): An integer to set height of result
            
            Returns:
                    wmsData_rxr (xarray dataarray): A xarray dataarray holding the image from the WebMapService
    &#39;&#39;&#39;
    from owslib.wms import WebMapService
    # Define WMS endpoint URL
    if &#39;wms_url&#39; in kwargs:
        wms_url = kwargs[&#39;wms_url&#39;]
    else:
        wms_url = wms_url
    # Create WMS connection object
    wms = WebMapService(wms_url)
    # Print available layers
    #print(wms.contents)
    # Select desired layer
    if &#39;layer_name&#39; in kwargs:
        layer = kwargs[&#39;layer_name&#39;]
    else:
        layer = layer_name
    
    data = wms.contents#[layer]
    print(data[&#39;0&#39;].__dict__)
    if &#39;srs&#39; in kwargs:
        studyArea_proj = study_area.to_crs(kwargs[&#39;srs&#39;])
        saBBox = studyArea_proj.total_bounds
    else:
        studyArea_proj = study_area.to_crs(srs)
    
    saBBox = studyArea_proj.total_bounds

    if layer == &#39;IL_Statewide_Lidar_DEM_WGS:None&#39;:
        dBBox = data[&#39;0&#39;].boundingBox #Is this an error?
        print(dBBox)

        gpdDict = {&#39;Label&#39;: [&#39;Surf Data Box&#39;], &#39;geometry&#39;: [shapely.geometry.Polygon(((dBBox[0], dBBox[1]), (dBBox[0], dBBox[3]), (dBBox[2], dBBox[3]), (dBBox[2], dBBox[1]), (dBBox[0], dBBox[1])))]}
        dBBoxGDF = gpd.GeoDataFrame(gpdDict, crs=dBBox[4])
        dBBoxGDF.to_crs(srs)
        #In case study area bounding box goes outside data bounding box, use data bounding box values
        newBBox = []
        for i,c in enumerate(dBBox):
            if type(c) is str:
                pass
            elif i == 0 or i==2:
                if saBBox[i] &lt; c:
                    newBBox.append(saBBox[i])
                else:
                    newBBox.append(c)
            else:
                if saBBox[i] &gt; c:
                    newBBox.append(saBBox[i])
                else:
                    newBBox.append(c)

    saWidth = saBBox[2]-saBBox[0]
    saHeight = saBBox[3]-saBBox[1]    
    print(&#39;Done with bbx&#39;)
    # Check kwargs for rest of parameters
    if &#39;size_x&#39; in kwargs:
        size_x = kwargs[&#39;size_x&#39;]
    if &#39;size_y&#39; in kwargs:
        size_y = kwargs[&#39;size_y&#39;]
    if &#39;format&#39; in kwargs:
        format = kwargs[&#39;format&#39;]
    if &#39;clip_to_studyarea&#39; in kwargs:
        clip_to_studyarea = kwargs[&#39;clip_to_studyarea&#39;]
    #get the wms
    print(saBBox)

    if clip_to_studyarea:
        img = wms.getmap(layers=[layer], srs=srs, bbox=saBBox, size=(size_x, size_y), format=format, transparent=True, timeout=60)        
    else:
        img = wms.getmap(layers=[layer], srs=srs, bbox=bbox, size=(size_x, size_y), format=format, transparent=True, timeout=60)
    print(&#39;Done with getmap&#39;)

    #with open(&#39;statewide_test.tiff&#39;, &#39;wb&#39;) as f: 
    #    f.write(img.read())
    #Save wms in memory to a raster dataset
    with MemoryFile(img) as memfile:
        with memfile.open() as dataset:
            wmsData_rxr = rxr.open_rasterio(dataset)

    #if clip_to_studyarea:
    #    wmsData_rxr = wmsData_rxr.sel(x=slice(saBBox[0], saBBox[2]), y=slice(saBBox[3], saBBox[1]))#.sel(band=1)

    return wmsData_rxr</code></pre>
</details>
</dd>
<dt id="w4h.mapping.read_grid"><code class="name flex">
<span>def <span class="ident">read_grid</span></span>(<span>datapath='', grid_type='model', nodataval=0, use_service=False, studyArea='', clip2SA=True, studyAreacrs=None, gridcrs=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_grid(datapath=&#39;&#39;, grid_type=&#39;model&#39;, nodataval=0, use_service=False, studyArea=&#39;&#39;, clip2SA=True,  studyAreacrs=None, gridcrs=None, **kwargs):
    if grid_type==&#39;model&#39;:
        if &#39;read_grid&#39; in list(kwargs.keys()):
            rgrid = kwargs[&#39;read_grid&#39;]
        else:
            rgrid=True
        gridIN = read_model_grid(studyArea, gridpath=datapath, nodataval=0, read_grid=rgrid, clip2SA=clip2SA, studyAreacrs=studyAreacrs, gridcrs=gridcrs)
    else:
        if use_service==False:
            gridIN = rxr.open_rasterio(datapath)
        elif use_service.lower()==&#39;wcs&#39;:
            gridIN = readWCS(studyArea, wcs_url=lidarURL, **kwargs)
        elif use_service.lower()==&#39;wms&#39;:
            pass
            gridIN = readWMS(studyArea, wcs_url=lidarURL, **kwargs)
            
        if clip2SA:
            if gridcrs is None:
                try:
                    gridcrs=gridIN.spatial_ref.crs_wkt
                except:
                    iswsCRS = w4h.read_dict(r&#39;../resources/isws_crs&#39;)
                    gridIN.rio.write_crs(iswsCRS)
            elif gridcrs.lower()==&#39;isws&#39;:
                iswsCRS = w4h.read_dict(r&#39;../resources/isws_crs&#39;)
                gridIN.rio.write_crs(iswsCRS)
                
            if studyAreacrs is None:
                studyAreacrs=studyArea.crs
            studyArea = studyArea.to_crs(gridcrs)
            studyAreacrs=studyArea.crs
            
            gridIN = clipGrid2StudyArea(studyArea=studyArea, grid=gridIN, studyAreacrs=studyAreacrs, gridcrs=gridcrs)
        try:
            nodataval = gridIN.attrs[&#39;_FillValue&#39;] #Extract from dataset itself
        except:
            pass
                
        gridIN = gridIN.where(gridIN != nodataval, other=np.nan)  #Replace no data values with NaNs

    return gridIN</code></pre>
</details>
</dd>
<dt id="w4h.mapping.read_model_grid"><code class="name flex">
<span>def <span class="ident">read_model_grid</span></span>(<span>studyArea, gridpath, nodataval=0, read_grid=True, node_bySpace=False, clip2SA=True, studyAreacrs=None, gridcrs=None)</span>
</code></dt>
<dd>
<div class="desc"><p><em>summary</em></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>studyArea</code></strong> :&ensp;<code>_type_</code></dt>
<dd><em>description</em></dd>
<dt><strong><code>gridpath</code></strong> :&ensp;<code>_type_</code></dt>
<dd><em>description</em></dd>
<dt><strong><code>nodataval</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd><em>description</em>, by default 0</dd>
<dt><strong><code>readGrid</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd><em>description</em>, by default True</dd>
<dt><strong><code>node_bySpace</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd><em>description</em>, by default False</dd>
<dt><strong><code>clip2SA</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd><em>description</em>, by default True</dd>
<dt><strong><code>studyAreacrs</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd><em>description</em>, by default ''</dd>
<dt><strong><code>gridcrs</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd><em>description</em>, by default ''</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>_type_</code></dt>
<dd><em>description</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_model_grid(studyArea, gridpath, nodataval=0, read_grid=True, node_bySpace=False, clip2SA=True, studyAreacrs=None, gridcrs=None):
    &#34;&#34;&#34;_summary_

    Parameters
    ----------
    studyArea : _type_
        _description_
    gridpath : _type_
        _description_
    nodataval : int, optional
        _description_, by default 0
    readGrid : bool, optional
        _description_, by default True
    node_bySpace : bool, optional
        _description_, by default False
    clip2SA : bool, optional
        _description_, by default True
    studyAreacrs : str, optional
        _description_, by default &#39;&#39;
    gridcrs : str, optional
        _description_, by default &#39;&#39;

    Returns
    -------
    _type_
        _description_
    &#34;&#34;&#34;
    read_grid = True
    node_bySpace = False #False means by number of nodes
    
    if read_grid:
        modelGridIN = rxr.open_rasterio(gridpath)

        file = w4h.get_resource_path(&#39;isws_crs.txt&#39;)
        iswsCRS = w4h.read_dict(file, keytype=None)

        if gridcrs is None:
            try:
                gridcrs=modelGridIN.spatial_ref.crs_wkt
            except:
                modelGridIN.rio.write_crs(iswsCRS)
        elif gridcrs.lower()==&#39;isws&#39;:
            modelGridIN.rio.write_crs(iswsCRS)
        
        if clip2SA:                
            if studyAreacrs is None:
                studyAreacrs=studyArea.crs
            studyArea = studyArea.to_crs(gridcrs)
            studyAreacrs=studyArea.crs            
            modelGrid = clipGrid2StudyArea(studyArea=studyArea, grid=modelGridIN, studyAreacrs=studyAreacrs, gridcrs=gridcrs)
        try:
            noDataVal = float(modelGrid.attrs[&#39;_FillValue&#39;]) #Extract from dataset itsel
        except:
            noDataVal = -5000000

        modelGrid = modelGrid.where(modelGrid != noDataVal, other=np.nan)   #Replace no data values with NaNs
        modelGrid.rio.reproject(iswsCRS, inplace=True)
    else:
        spatRefDict = {&#39;crs_wkt&#39;: &#39;PROJCS[&#34;Clarke_1866_Lambert_Conformal_Conic&#34;,GEOGCS[&#34;NAD27&#34;,DATUM[&#34;North_American_Datum_1927&#34;,SPHEROID[&#34;Clarke 1866&#34;,6378206.4,294.978698199999,AUTHORITY[&#34;EPSG&#34;,&#34;7008&#34;]],AUTHORITY[&#34;EPSG&#34;,&#34;6267&#34;]],PRIMEM[&#34;Greenwich&#34;,0],UNIT[&#34;degree&#34;,0.0174532925199433,AUTHORITY[&#34;EPSG&#34;,&#34;9122&#34;]],AUTHORITY[&#34;EPSG&#34;,&#34;4267&#34;]],PROJECTION[&#34;Lambert_Conformal_Conic_2SP&#34;],PARAMETER[&#34;latitude_of_origin&#34;,33],PARAMETER[&#34;central_meridian&#34;,-89.5],PARAMETER[&#34;standard_parallel_1&#34;,33],PARAMETER[&#34;standard_parallel_2&#34;,45],PARAMETER[&#34;false_easting&#34;,2999994],PARAMETER[&#34;false_northing&#34;,0],UNIT[&#34;US survey foot&#34;,0.304800609601219,AUTHORITY[&#34;EPSG&#34;,&#34;9003&#34;]],AXIS[&#34;Easting&#34;,EAST],AXIS[&#34;Northing&#34;,NORTH]]&#39;,
            &#39;semi_major_axis&#39;: 6378206.4,
            &#39;semi_minor_axis&#39;: 6356583.799998981,
            &#39;inverse_flattening&#39;: 294.978698199999,
            &#39;reference_ellipsoid_name&#39;: &#39;Clarke 1866&#39;,
            &#39;longitude_of_prime_meridian&#39;: 0.0,
            &#39;prime_meridian_name&#39;: &#39;Greenwich&#39;,
            &#39;geographic_crs_name&#39;: &#39;NAD27&#39;,
            &#39;horizontal_datum_name&#39;: &#39;North American Datum 1927&#39;,
            &#39;projected_crs_name&#39;: &#39;Clarke_1866_Lambert_Conformal_Conic&#39;,
            &#39;grid_mapping_name&#39;: &#39;lambert_conformal_conic&#39;,
            &#39;standard_parallel&#39;: (33.0, 45.0),
            &#39;latitude_of_projection_origin&#39;: 33.0,
            &#39;longitude_of_central_meridian&#39;: -89.5,
            &#39;false_easting&#39;: 2999994.0,
            &#39;false_northing&#39;: 0.0,
            &#39;spatial_ref&#39;: &#39;PROJCS[&#34;Clarke_1866_Lambert_Conformal_Conic&#34;,GEOGCS[&#34;NAD27&#34;,DATUM[&#34;North_American_Datum_1927&#34;,SPHEROID[&#34;Clarke 1866&#34;,6378206.4,294.978698199999,AUTHORITY[&#34;EPSG&#34;,&#34;7008&#34;]],AUTHORITY[&#34;EPSG&#34;,&#34;6267&#34;]],PRIMEM[&#34;Greenwich&#34;,0],UNIT[&#34;degree&#34;,0.0174532925199433,AUTHORITY[&#34;EPSG&#34;,&#34;9122&#34;]],AUTHORITY[&#34;EPSG&#34;,&#34;4267&#34;]],PROJECTION[&#34;Lambert_Conformal_Conic_2SP&#34;],PARAMETER[&#34;latitude_of_origin&#34;,33],PARAMETER[&#34;central_meridian&#34;,-89.5],PARAMETER[&#34;standard_parallel_1&#34;,33],PARAMETER[&#34;standard_parallel_2&#34;,45],PARAMETER[&#34;false_easting&#34;,2999994],PARAMETER[&#34;false_northing&#34;,0],UNIT[&#34;US survey foot&#34;,0.304800609601219,AUTHORITY[&#34;EPSG&#34;,&#34;9003&#34;]],AXIS[&#34;Easting&#34;,EAST],AXIS[&#34;Northing&#34;,NORTH]]&#39;,
            &#39;GeoTransform&#39;: &#39;2440250.0 625.0 0.0 3459750.0 0.0 -625.0&#39;}
        
        saExtent = studyArea.total_bounds

        startX = saExtent[0] #Starting X Coordinate
        startY = saExtent[1] #starting Y Coordinate
        
        endX = saExtent[2]
        endY = saExtent[3]
        
        if node_bySpace:
            xSpacing = 625 #X Node spacing 
            ySpacing = xSpacing #Y Node spacing  
            
            x = np.arange(startX, endX, xSpacing)
            y = np.arange(startY, endY, ySpacing)
        else:
            xNodes = 100 #Number of X Nodes
            yNodes = 100 #Number of Y Nodes

            x = np.linspace(startX, endX, num=xNodes)
            y = np.linspace(startY, endY, num=yNodes)        
        
        xx, yy = np.meshgrid(x, y)
        zz = np.ones_like(xx).transpose()

        yIn = np.flipud(y)

        coords = {&#39;x&#39;:x,&#39;y&#39;:yIn, &#39;spatial_ref&#39;:0}
        dims = {&#39;x&#39;:x,&#39;y&#39;:yIn}
        
        modelGrid = xr.DataArray(data=zz,coords=coords,attrs={&#39;_FillValue&#39;:3.402823466e+38}, dims=dims)
        modelGrid.spatial_ref.attrs[&#39;spatial_ref&#39;] = {}
        if gridcrs is None or gridcrs==&#39;isws&#39; or gridcrs==&#39;ISWS&#39;:
            for k in spatRefDict:
                modelGrid.spatial_ref.attrs[k] = spatRefDict[k]
    return modelGrid</code></pre>
</details>
</dd>
<dt id="w4h.mapping.read_study_area"><code class="name flex">
<span>def <span class="ident">read_study_area</span></span>(<span>studyareapath, crs='')</span>
</code></dt>
<dd>
<div class="desc"><p>Read study area geospatial file into geopandas</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>studyareapath</code></strong> :&ensp;<code>str</code> or <code>pathlib.Path</code></dt>
<dd>Filepath to any geospatial file readable by geopandas.
Polygon is best, but may work with other types if extent is correct.</dd>
<dt><strong><code>crs</code></strong> :&ensp;<code>str, tuple, dict</code>, optional</dt>
<dd>CRS designation readable by geopandas/pyproj</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>studyAreaIN</code></strong> :&ensp;<code>geopandas dataframe</code></dt>
<dd>Geopandas dataframe with polygon geometry.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_study_area(studyareapath, crs=&#39;&#39;):
    &#34;&#34;&#34;Read study area geospatial file into geopandas

    Parameters
    ----------
    studyareapath : str or pathlib.Path
        Filepath to any geospatial file readable by geopandas. 
        Polygon is best, but may work with other types if extent is correct.
    crs : str, tuple, dict, optional
        CRS designation readable by geopandas/pyproj

    Returns
    -------
    studyAreaIN : geopandas dataframe
        Geopandas dataframe with polygon geometry.
    &#34;&#34;&#34;
    studyAreaIN = gpd.read_file(studyareapath)
    return studyAreaIN</code></pre>
</details>
</dd>
<dt id="w4h.mapping.sample_raster_points"><code class="name flex">
<span>def <span class="ident">sample_raster_points</span></span>(<span>raster, points_df, xCol='LONGITUDE', yCol='LATITUDE', newColName='SAMPLED', printouts=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample raster values to points from geopandas geodataframe.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>raster</code></strong> :&ensp;<code>rioxarray data array</code></dt>
<dd>Raster containing values to be sampled.</dd>
<dt><strong><code>points_df</code></strong> :&ensp;<code>geopandas.geodataframe</code></dt>
<dd>Geopandas dataframe with geometry column containing point values to sample.</dd>
<dt><strong><code>xCol</code></strong> :&ensp;<code>str</code>, default=<code>'LONGITUDE'</code></dt>
<dd>Column containing name for x-column, by default 'LONGITUDE.'
This is used to output (potentially) reprojected point coordinates so as not to overwrite the original.</dd>
<dt><strong><code>yCol</code></strong> :&ensp;<code>str</code>, default=<code>'LATITUDE'</code></dt>
<dd>Column containing name for y-column, by default 'LATITUDE.'
This is used to output (potentially) reprojected point coordinates so as not to overwrite the original.
newColName : str, optional</dd>
<dt><strong><code>newColName</code></strong> :&ensp;<code>str</code>, default=<code>'SAMPLED'</code></dt>
<dd>Name for name of new column containing points sampled from the raster, by default 'SAMPLED'.</dd>
<dt><strong><code>printouts</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>Whether to send to print() information about progress of function, by default True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>points_df</code></strong> :&ensp;<code>geopandas.geodataframe</code></dt>
<dd>Same as points_df, but with sampled values and potentially with reprojected coordinates.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_raster_points(raster, points_df, xCol=&#39;LONGITUDE&#39;, yCol=&#39;LATITUDE&#39;, newColName=&#39;SAMPLED&#39;, printouts=True):  
    &#34;&#34;&#34;Sample raster values to points from geopandas geodataframe.

    Parameters
    ----------
    raster : rioxarray data array
        Raster containing values to be sampled.
    points_df : geopandas.geodataframe
        Geopandas dataframe with geometry column containing point values to sample.
    xCol : str, default=&#39;LONGITUDE&#39;
        Column containing name for x-column, by default &#39;LONGITUDE.&#39;
        This is used to output (potentially) reprojected point coordinates so as not to overwrite the original.
    yCol : str, default=&#39;LATITUDE&#39;
        Column containing name for y-column, by default &#39;LATITUDE.&#39;
        This is used to output (potentially) reprojected point coordinates so as not to overwrite the original.    newColName : str, optional
    newColName : str, default=&#39;SAMPLED&#39;
        Name for name of new column containing points sampled from the raster, by default &#39;SAMPLED&#39;.
    printouts : bool, default=True
        Whether to send to print() information about progress of function, by default True.

    Returns
    -------
    points_df : geopandas.geodataframe
        Same as points_df, but with sampled values and potentially with reprojected coordinates.
    &#34;&#34;&#34;
    if printouts:
        nowTime = datetime.datetime.now()
        expectMin = (points_df.shape[0]/3054409) * 14
        endTime = nowTime+datetime.timedelta(minutes=expectMin)
        print(newColName+ &#34; sampling should be done by {:d}:{:02d}&#34;.format(endTime.hour, endTime.minute))

    #Project points to raster CRS
    rastercrsWKT=raster.spatial_ref.crs_wkt
    points_df = points_df.to_crs(rastercrsWKT)
    #if xCol==&#39;LONGITUDE&#39; and yCol==&#39;LATITUDE&#39;:
    xCOLOUT = xCol+&#39;_PROJ&#39;
    yCOLOUT = yCol+&#39;_PROJ&#39;
    points_df[xCOLOUT] = points_df[&#39;geometry&#39;].x
    points_df[yCOLOUT] = points_df[&#39;geometry&#39;].y
    xData = np.array(points_df[xCOLOUT].values)
    yData = np.array(points_df[yCOLOUT].values)
    sampleArr=raster.sel(x=xData, y=yData, method=&#39;nearest&#39;).values
    sampleArr = np.diag(sampleArr)
    sampleDF = pd.DataFrame(sampleArr, columns=[newColName])
    points_df[newColName] = sampleDF[newColName]
    return points_df</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="w4h" href="index.html">w4h</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="w4h.mapping.addElevtoHeader" href="#w4h.mapping.addElevtoHeader">addElevtoHeader</a></code></li>
<li><code><a title="w4h.mapping.alignRasters" href="#w4h.mapping.alignRasters">alignRasters</a></code></li>
<li><code><a title="w4h.mapping.clipGrid2StudyArea" href="#w4h.mapping.clipGrid2StudyArea">clipGrid2StudyArea</a></code></li>
<li><code><a title="w4h.mapping.clipHeader2StudyArea" href="#w4h.mapping.clipHeader2StudyArea">clipHeader2StudyArea</a></code></li>
<li><code><a title="w4h.mapping.coords2Geometry" href="#w4h.mapping.coords2Geometry">coords2Geometry</a></code></li>
<li><code><a title="w4h.mapping.get_drift_thick" href="#w4h.mapping.get_drift_thick">get_drift_thick</a></code></li>
<li><code><a title="w4h.mapping.readWCS" href="#w4h.mapping.readWCS">readWCS</a></code></li>
<li><code><a title="w4h.mapping.readWMS" href="#w4h.mapping.readWMS">readWMS</a></code></li>
<li><code><a title="w4h.mapping.read_grid" href="#w4h.mapping.read_grid">read_grid</a></code></li>
<li><code><a title="w4h.mapping.read_model_grid" href="#w4h.mapping.read_model_grid">read_model_grid</a></code></li>
<li><code><a title="w4h.mapping.read_study_area" href="#w4h.mapping.read_study_area">read_study_area</a></code></li>
<li><code><a title="w4h.mapping.sample_raster_points" href="#w4h.mapping.sample_raster_points">sample_raster_points</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>